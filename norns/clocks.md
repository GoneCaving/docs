---
layout: default
parent: scripting
grand_parent: norns
title: clocks
nav_order: 3
permalink: /norns/clocks/
---

# clocks

the clock library provides a way to create timed function calls: loops, repetition, and delays. synchronization is possible and time base can come from a variety of sources.

## commands

- `id = clock.run( func )` &mdash; start a new clock with function _func_. returns _id_
- `clock.cancel( id )` &mdash; cancel clock _id_ 
- `clock.sleep( time )` &mdash; resume in _time_ seconds
- `clock.sync( beats )` &mdash; resume in _beats_ according to tempo
- `beats = clock.get_time_beats()` &mdash; returns current time in _beats_
- `tempo = clock.get_tempo()` &mdash; returns current _tempo_
- `beat_sec = clock.get_beat_sec()` &mdash; returns length of beat in seconds

## callbacks

these functions can be script defined and are called by system events:

- `clock.transport.start` &mdash; called by transport start
- `clock.transport.stop` &mdash; called by transport stop

## use

### simple delay

`clock.run` starts a new clock with the function you provide:

```
function later()
  clock.sleep(2)
  print("now awake")
end

function init()
  print("starting now")
  clock.run(later)
  print("done with init")
end
```

when executed, you will see _starting now_, _done with init_, (two seconds delay and then): _now awake_. `clock.run` starts a coroutine with the function `later`. this functions immediately sleeps for two seconds, which means the `init` function resumes.
   
### repetition and sync

you can sleep according to units of tempo (beats) by using `clock.sync` instead of `clock.sleep`.

```
engine.name = 'PolyPerc'

function strum()
  for i=1,8 do
    engine.hz(i*100)
    clock.sync(1/4)
  end
end

function key(n,z)
  if n==3 and z==1 then
    clock.run(strum)
  end
end
```

this script creates a new clock when K3 is pressed. the `strum` function plays eight notes, sleeping for 1/4 of a beat between notes.

you can change the global tempo using parameters via command or menu. see the later section.

### arguments

pass arguments to a clock function by appending them within the `clock.run` call:

```
engine.name = 'PolyPerc'

function strum(n,speed)
  for i=1,n do
    clock.sync(1/speed)
    engine.hz(i*100)
  end
end

function key(n,z)
  if n==3 and z==1 then
    clock.run(strum, math.random(16), math.random(8))
  end
end
```

now each `strum` is executed with different agruments. note that you can overlap multiple runs by pressing the key rapidly! a new coroutine is created with each run, so you can have numerous clock processes running at once.

`clock.sync` sleeps until the next subdivision specified arrives, so the timing is effectively quantized to the master tempo (which is the goal of this use case).

### loop

so far all of our clock functions end by themselves, by reaching the end of their own execution. we can create forever-running loops using a `while true` inner loop. these will continue running until you cancel them manually with `clock.cancel`, or by launch a new script.

```
engine.name = 'PolyPerc'

clock_id = 0

function forever(freq)
  while(true) do
    clock.sync(1/4)
    engine.hz(freq)
  end
end

function init()
  clock_id = clock.run(forever, 220)
end

function key(n,z)
  if n==3 and z==1 then
    clock.cancel(clock_id)
  end
end
```

to cancel a clock you need to save its `id`.

### multiples

you can run lots of clocks at once: up to 100.

```
engine.name = 'PolyPerc'

function forever(freq,rate)
  while(true) do
    clock.sync(1/rate)
    engine.hz(freq)
  end
end

function init()
  clock.run(forever,333,3)
  clock.run(forever,666,1)
  clock.run(forever,999,2)
  clock.run(forever,111,0.33)
end
```

### query

you can query the current tempo, beats, and seconds-per-beat:

```
print(clock.get_tempo())
t = clock.get_beats()
softcut.loop_start(1,clock.get_beats_sec())
```

### callbacks

scripts can define their own callback functions for transport start and stop:

```
saved_id = 0

function clock.transport.start()
  print("we begin")
  saved_id = clock.run(something)
end

function clock.transport.stop()
  clock.cancel(saved_id)
end
```

remote start/stop events can be generated by link or external midi.


## parameters

the `CLOCK` menu is available in the `PARAMETERS` screen.

### source

this sets the sync source for the global tempo.

- `internal` sets norns as the clock source
- `midi` takes any external midi clock via connected USB midi devices
- `link` enables ableton link sync for the connecting wifi network
- `crow` takes sync from input 1 of a connected crow device

link has a `link quantum` parameter to set the quantum size.

crow additionally has a `crow in div` parameter to specify the number of sub-divisions per beat.

the `tempo` parameter sets the internal and link tempos. this tempo will be automatically updated if set by an external source (midi, crow, or remote link device).

### out

clock signals can be transmitted via midi or crow.

`midi out` sets the port number (which midi device, via SYSTEM > DEVICES) on which to transmit.

`crow out` sets the output number, and also has a `crow out div` setting for beat subdivisions.

---
